var documenterSearchIndex = {"docs":
[{"location":"motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"lazy_broadcast is useful in a few situations:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Improved expressibility + fusing operations\nDebugging broadcast machinery\nDelaying execution of a broadcast expression","category":"page"},{"location":"motivation/#Improved-expressibility-fusing-operations","page":"Motivation","title":"Improved expressibility + fusing operations","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"You may have an implimentation of broadcast that involves a matrix-vector multiplication, suppose we have two operators, foo_op and bar_op","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"has_foo_model && @. x += 2 * foo_op(y)\nhas_bar_model && @. x += 3 + bar_op(y)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"and if foo_op and bar_op are broadcasted in an implementation-specific way, you may not be able to (easily) write this to leverage dispatch:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"foo(y, ::NoFooModel) = 0\nfoo(y, ::HasFooModel) = 2 * foo_op(y)\nbar(y, ::NoBarModel) = 0\nbar(y, ::HasBarModel) = 3 + bar_op(y)\n@. x += foo(y, model) + bar(y, model)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"since foo_op and bar_op may need to exist in the broadcasted expression. It turns out that this is pretty easy to do with LazyBroadcast:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"foo(y, ::NoFooModel) = 0\nfoo(y, ::HasFooModel) = @lazy @. 2 * foo_op(y)\nbar(y, ::NoBarModel) = 0\nbar(y, ::HasBarModel) = @lazy @. 3 + bar_op(y)\n@. x += foo(y, model) + bar(y, model)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"This form has some advantages:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"we've fused the reads of vectors x and y, which can result in notably better performance\nwe've not duplicated logic (much). We could potentially use union splitting to achieve fusion, but this can become unwieldy as the number of combinations of cases increases.\nthe new functions would be in functional form, and more easily unit-tested","category":"page"},{"location":"motivation/#Debugging-broadcast-machinery","page":"Motivation","title":"Debugging broadcast machinery","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"If you overload Julia's broadcast software layer, then you may find yourself constructing broadcast objects and working with them to write unit test on your overloaded implementation of broadcast. We've often found it more convenient to construct Base.Broadcasted objects using the standard dot-syntax + LazyBroadcast. Here is an example, instead of writing:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"x = [1, 2]\ny = [1, 2]\na = Base.Broadcast.instantiate\n(Base.Broadcast.broadcasted(+ x, y))","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"You can write","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"using\nLazyBroadcast: lazy_broadcast\nx = [1, 2]\ny = [1, 2]\na = lazy_broadcast.(x .+ y)","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"which is typically the more common form that broadcast expressions exist in applications.","category":"page"},{"location":"motivation/#Delaying-execution-of-a-broadcast-expression","page":"Motivation","title":"Delaying execution of a broadcast expression","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Another interesting use-case of LazyBroadcast is to use it for delaying execution.","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"For example, we can write an expression:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"using LazyBroadcast: lazy_broadcast\na = [0, 0]\nb = [0, 0]\nc = lazy_broadcast.(a .+ b)\nnothing","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Perform calculations","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"a .= [1, 1]\nb .= [1, 1]\nnothing","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"And then finally evaluate the expression:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Base.materialize(c)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Featured-functions-and-macros","page":"API","title":"Featured functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LazyBroadcast defines two exported functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"lazy_broadcast - the main feature of LazyBroadcast, which turns broadcast expressions into lazy broadcasted objects.\n@lazy_broadcast - which allows users to call lazy_broadcast without parenthesis.","category":"page"},{"location":"api/","page":"API","title":"API","text":"and two un-exported functions (un-exported intentionally to avoid name collisions)","category":"page"},{"location":"api/","page":"API","title":"API","text":"lazy - an alias of lazy_broadcast\n@lazy - an alias of @lazy_broadcast","category":"page"},{"location":"api/#lazy_broadcast","page":"API","title":"lazy_broadcast","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LazyBroadcast.lazy_broadcast","category":"page"},{"location":"api/#LazyBroadcast.lazy_broadcast","page":"API","title":"LazyBroadcast.lazy_broadcast","text":"function lazy_broadcast end # exported\nconst lazy = lazy_broadcast # not exported\n\nThis function has no methods and is only meant to be used to consume a broadcast expression, causing it to not materialize, allowing it to be used in a lazy manner and be consumed later.\n\nFor example, consider the situation where one wants to break up a complicated broadcast expression into multiple steps, and then sum up all of the components:\n\njulia> function foo(x)\n           y = x .+ x\n           z = 2 .* y\n           sum(z)\n       end;\n\njulia> @benchmark foo(v) setup=(v=rand(10))\nBenchmarkTools.Trial: 10000 samples with 995 evaluations.\n Range (min … max):  31.405 ns …  4.801 μs  ┊ GC (min … max):  0.00% … 98.56%\n Time  (median):     34.809 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   45.504 ns ± 93.354 ns  ┊ GC (mean ± σ):  20.30% ± 11.70%\n\n  █▅▃▂                                                        ▁\n  █████▆▅▅▅▅▅▅▁▄▅▅▇▅▃▁▁▁▄▅▅▁▁▁▁▁▃▁▁▁▁▁▄▁▅▁▁▁▁▁▃▅▆▅▄▅▄▁▄▄▆▆▅▄▅ █\n  31.4 ns      Histogram: log(frequency) by time       298 ns <\n\n Memory estimate: 288 bytes, allocs estimate: 4.\n\nThis is significantly slower than it needs to be because new arrays need to be allocated for y and z, and the data needs to be passed over multiple times because the broadcast kernels are not 'fused'.\n\nDontMaterialize gives a simple way to avoid these allocations and retain broadcast fusion:\n\njulia> function bar(x)\n           y = lazy_broadcast.(x .+ x)\n           z = lazy_broadcast.(2 .* y)\n           sum(z)\n       end;\n\njulia> @benchmark bar(v) setup=(v=rand(10))\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  5.931 ns … 59.562 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     6.252 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   6.435 ns ±  2.767 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n        ▁█\n  ▃▂▃▃▄▇██▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▂▂▂▂▂▂▂▂▂▂ ▂\n  5.93 ns        Histogram: frequency by time        8.75 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\nthe result of a lazy_broadcast call can be collected into an array with the materialize function (re-exported here from Base.Broadcast):\n\njulia> lazy_broadcast.(2 .* [1,2,3])\nBroadcasted{Base.Broadcast.DefaultArrayStyle{1}}(*, (2, [1, 2, 3]))\n\njulia> materialize(ans)\n3-element Vector{Int64}:\n 2\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Suppose we want to sum a vector, which is the result of multiple broadcast expressions: y = x .+ x, z = 2 .* y, and, finally, sum(z). Let's write this in a function, foo, and compare the result of using lazy_broadcast to compute the intermediate values.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Base.Broadcast: materialize\nusing LazyBroadcast: lazy_broadcast\nusing BenchmarkTools\n\nfunction foo(x)\n   y = x .+ x\n   z = 2 .* y\n   sum(z)\nend;\n\ntrial = @benchmark foo(v) setup=(v=rand(10))\nshow(stdout, MIME(\"text/plain\"), trial)\nprintln()\n\nfunction bar(x)\n   y = lazy_broadcast.(x .+ x)\n   z = lazy_broadcast.(2 .* y)\n   sum(z)\nend;\n\ntrial = @benchmark bar(v) setup=(v=rand(10))\nshow(stdout, MIME(\"text/plain\"), trial)\nprintln()","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"On my computer, the benchmarks take 43.433 ns and 5.917 ns, respectively. So, using LazyBroadcast results in a 7x speedup. This demonstrates the power of using lazy_broadcast, which allows us to avoid allocating temporary arrays.","category":"page"},{"location":"caveats/#Caveats","page":"Caveats","title":"Caveats","text":"","category":"section"},{"location":"caveats/","page":"Caveats","title":"Caveats","text":"There are some caveats of working with lazy objects: the construction of broadcasted objects and their execution can become separated, requiring more thought. For example:","category":"page"},{"location":"caveats/","page":"Caveats","title":"Caveats","text":"using LazyBroadcast: lazy_broadcast\na = [0, 0]\nb = [0, 0]\nc = lazy_broadcast.(a .+ b)\na .= [1, 1]\nb .= [1, 1]\nnothing","category":"page"},{"location":"caveats/","page":"Caveats","title":"Caveats","text":"What do you suppose that the result of Base.materialize(c) is now? Let's see:","category":"page"},{"location":"caveats/","page":"Caveats","title":"Caveats","text":"Base.materialize(c)","category":"page"},{"location":"caveats/","page":"Caveats","title":"Caveats","text":"Tada! c is a Base.Broadcasted object that holds pointers to the data a and b, so even though we've since mutated a and b after assigning c, materializing c will yield results for whatever values that a and b contain at that instant. This might be surprising at first, but it's also very powerful. We can think of c as an expression, that holds true for whatever values we put into a and b.","category":"page"},{"location":"broadcast_background/#Julia-Base-Broadcast-Background","page":"Broadcast background","title":"Julia Base Broadcast Background","text":"","category":"section"},{"location":"broadcast_background/","page":"Broadcast background","title":"Broadcast background","text":"Please see the official Julia broadcasting documentation, for more information.","category":"page"},{"location":"broadcast_background/","page":"Broadcast background","title":"Broadcast background","text":"Here, we'll give a brief background of Julia Base's broadcast machinery.","category":"page"},{"location":"broadcast_background/#From-parse-time-to-runtime","page":"Broadcast background","title":"From parse time to runtime","text":"","category":"section"},{"location":"broadcast_background/","page":"Broadcast background","title":"Broadcast background","text":"TODO","category":"page"},{"location":"how_it_works/#How-lazy_broadcast-works","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"","category":"section"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"It's actually very simple, and the entire package can be written in a few lines of code:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"using Base.Broadcast: broadcasted, materialize, instantiate\nfunction lazy_broadcast end\nstruct LazyBroadcasted{T}\n    value::T\nend\nBase.Broadcast.broadcasted(::typeof(lazy_broadcast), x) = LazyBroadcasted(x)\nBase.materialize(x::LazyBroadcasted) = instantiate(x.value)","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"That's it. If you have not read the section on broadcast background, then you may want to read that, first. Assuming you've read that section, the idea is simple, and we can outline what happens in a few steps. Let's first consider a simple example:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"x = [1, 2]\ny = [1, 2]\nz = x .+ y","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"First, the code is lowered, and we can see what the code is lowered to using Julia's meta-programming utilities:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"julia> Meta.@lower(x .+ y)\n:($(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─ %1 = Base.broadcasted(+, x, y)\n│   %2 = Base.materialize(%1)\n└──      return %2\n))))","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"Now, you can see that our expression is transformed into a CodeInfo object, which contains a sequence of steps. If we back-substitute these expressions, we get Base.materialize(Base.broadcasted(+, x, y)), which is exactly what LazyBroadcast.code_lowered_single_expression(:(x .+ y)) returns:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"julia> LazyBroadcast.code_lowered_single_expression(:(x .+ y))\n:(Base.materialize(Base.broadcasted(+, x, y)))","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"Note that Base.materialize calls Base.Broadcast.instantiate on the input argument, so let's take a look at the instantiated argument to Base.materialize:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"julia> Base.Broadcast.instantiate(Base.broadcasted(+, x, y))\nBase.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}}(+, ([1, 2], [1, 2]))","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"Here's where the magic comes in. Looking back at the implementation from above, we know that","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"When we broadcast lazy_broadcast over an expression x, Base.broadcasted returns LazyBroadcasted(expr), and\nBase.materialize(::LazyBroadcast) simply returns x","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"So, the result is:","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"julia> bc = LazyBroadcast.lazy_broadcast.(x .+ y)\nBase.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}}(+, ([1, 2], [1, 2]))","category":"page"},{"location":"how_it_works/","page":"How lazy_broadcast works","title":"How lazy_broadcast works","text":"In other words, we get back the instantiated argument to Base.materialize. What's important to note here is that no computations occur until Base.materialize, so LazyBroadcast.lazy_broadcast.(x .+ y) returns a \"lazy\" object (a Base.Broadcasted object) that we can launch computations on, at any moment, by calling Base.materialize(bc).","category":"page"},{"location":"#LazyBroadcast.jl","page":"Home","title":"LazyBroadcast.jl","text":"","category":"section"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We believe that software should be","category":"page"},{"location":"","page":"Home","title":"Home","text":"simple\nunit tested\nfast\ngranular","category":"page"},{"location":"","page":"Home","title":"Home","text":"LazyBroadcast.jl helps us achieve via lazy_broadcast. lazy_broadcast can help you write more expressive code, and speed up your applications by fusing operations and eliminating intermediate allocations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To try this out, see our quick-start.","category":"page"}]
}
