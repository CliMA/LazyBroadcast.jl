var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Featured-functions-and-macros","page":"API","title":"Featured functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LazyBroadcast defines two exported functions:","category":"page"},{"location":"api/","page":"API","title":"API","text":"lazy_broadcast - the main feature of LazyBroadcast, which turns broadcast expressions into lazy broadcasted objects.\n@lazy_broadcast - which allows users to call lazy_broadcast without parenthesis.","category":"page"},{"location":"api/","page":"API","title":"API","text":"and two un-exported functions (un-exported intentionally to avoid name collisions)","category":"page"},{"location":"api/","page":"API","title":"API","text":"lazy - an alias of lazy_broadcast\n@lazy - an alias of @lazy_broadcast","category":"page"},{"location":"api/#lazy_broadcast","page":"API","title":"lazy_broadcast","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LazyBroadcast.lazy_broadcast","category":"page"},{"location":"api/#LazyBroadcast.lazy_broadcast","page":"API","title":"LazyBroadcast.lazy_broadcast","text":"function lazy_broadcast end # exported\nconst lazy = lazy_broadcast # not exported\n\nThis function has no methods and is only meant to be used to consume a broadcast expression, causing it to not materialize, allowing it to be used in a lazy manner and be consumed later.\n\nFor example, consider the situation where one wants to break up a complicated broadcast expression into multiple steps, and then sum up all of the components:\n\njulia> function foo(x)\n           y = x .+ x\n           z = 2 .* y\n           sum(z)\n       end;\n\njulia> @benchmark foo(v) setup=(v=rand(10))\nBenchmarkTools.Trial: 10000 samples with 995 evaluations.\n Range (min … max):  31.405 ns …  4.801 μs  ┊ GC (min … max):  0.00% … 98.56%\n Time  (median):     34.809 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   45.504 ns ± 93.354 ns  ┊ GC (mean ± σ):  20.30% ± 11.70%\n\n  █▅▃▂                                                        ▁\n  █████▆▅▅▅▅▅▅▁▄▅▅▇▅▃▁▁▁▄▅▅▁▁▁▁▁▃▁▁▁▁▁▄▁▅▁▁▁▁▁▃▅▆▅▄▅▄▁▄▄▆▆▅▄▅ █\n  31.4 ns      Histogram: log(frequency) by time       298 ns <\n\n Memory estimate: 288 bytes, allocs estimate: 4.\n\nThis is significantly slower than it needs to be because new arrays need to be allocated for y and z, and the data needs to be passed over multiple times because the broadcast kernels are not 'fused'.\n\nDontMaterialize gives a simple way to avoid these allocations and retain broadcast fusion:\n\njulia> function bar(x)\n           y = lazy_broadcast.(x .+ x)\n           z = lazy_broadcast.(2 .* y)\n           sum(z)\n       end;\n\njulia> @benchmark bar(v) setup=(v=rand(10))\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  5.931 ns … 59.562 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     6.252 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   6.435 ns ±  2.767 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n        ▁█\n  ▃▂▃▃▄▇██▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▁▂▂▂▂▂▂▂▂▂▂ ▂\n  5.93 ns        Histogram: frequency by time        8.75 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.\n\nthe result of a lazy_broadcast call can be collected into an array with the materialize function (re-exported here from Base.Broadcast):\n\njulia> lazy_broadcast.(2 .* [1,2,3])\nBroadcasted{Base.Broadcast.DefaultArrayStyle{1}}(*, (2, [1, 2, 3]))\n\njulia> materialize(ans)\n3-element Vector{Int64}:\n 2\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"Suppose we want to sum a vector, which is the result of multiple broadcast expressions: y = x .+ x, z = 2 .* y, and, finally, sum(z). Let's write this in a function, foo, and compare the result of using lazy_broadcast to compute the intermediate values.","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"using Base.Broadcast: materialize\nusing LazyBroadcast: lazy_broadcast\nusing BenchmarkTools\n\nfunction foo(x)\n   y = x .+ x\n   z = 2 .* y\n   sum(z)\nend;\n\n@benchmark foo(v) setup=(v=rand(10))\n\nfunction bar(x)\n   y = lazy_broadcast.(x .+ x)\n   z = lazy_broadcast.(2 .* y)\n   sum(z)\nend;\n\n@benchmark bar(v) setup=(v=rand(10))\nbc = lazy_broadcast.(2 .* [1,2,3])\nmaterialize(bc)","category":"page"},{"location":"quick_start/","page":"Quick start","title":"Quick start","text":"On my computer, the benchmarks take 43.433 ns and 5.917 ns, respectively. So, using LazyBroadcast results in a 7x speedup. This is achieved by avoiding temporary array allocations.","category":"page"},{"location":"broadcast_background/#Julia-Base-Broadcast-Background","page":"Broadcast background","title":"Julia Base Broadcast Background","text":"","category":"section"},{"location":"broadcast_background/","page":"Broadcast background","title":"Broadcast background","text":"Please see the official Julia broadcasting documentation, for more information.","category":"page"},{"location":"#LazyBroadcast.jl","page":"Home","title":"LazyBroadcast.jl","text":"","category":"section"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We believe that software should be","category":"page"},{"location":"","page":"Home","title":"Home","text":"simple\nunit tested\nfast\ngranular","category":"page"},{"location":"","page":"Home","title":"Home","text":"LazyBroadcast.jl helps us achieve this by providing a function, lazy_broadcast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function can be used to transform a given Julia broadcast expression into broadcasted objects and without materializing them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To try this out, see our quick-start guide.","category":"page"},{"location":"motivation/#Motivation","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"This utility is useful in a few situations:","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"Debugging broadcast machinery\nFusing operations in multiple broadcast expressions (alternatively, see MultiBroadcastFusion.jl)\nDelaying execution of a broadcast expression","category":"page"},{"location":"motivation/","page":"Motivation","title":"Motivation","text":"For not-in-place expressions, lazy_broadcast simply returns the instantiated broadcasted object, via Base.Broadcast.instantiate (Base.Broadcast.broadcasted(x)), of the right-hand-side:","category":"page"},{"location":"motivation/#Debuggin-broadcast-machinery","page":"Motivation","title":"Debuggin broadcast machinery","text":"","category":"section"},{"location":"motivation/#Fusing-multiple-broadcast-expressions","page":"Motivation","title":"Fusing multiple broadcast expressions","text":"","category":"section"},{"location":"motivation/#Delaying-execution-of-a-broadcast-expression","page":"Motivation","title":"Delaying execution of a broadcast expression","text":"","category":"section"}]
}
